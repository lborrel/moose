//* This file is part of the MOOSE framework
//* https://www.mooseframework.org
//*
//* All rights reserved, see COPYRIGHT for full restrictions
//* https://github.com/idaholab/moose/blob/master/COPYRIGHT
//*
//* Licensed under LGPL 2.1, please see LICENSE for details
//* https://www.gnu.org/licenses/lgpl-2.1.html

#include "PolynomialFit.h"

// C++ includes
#include <fstream>

int PolynomialFit::_file_number = 0;

PolynomialFit::PolynomialFit(const std::vector<Real> & x,
                             const std::vector<Real> & y,
                             unsigned int order,
                             bool truncate_order)
  : LeastSquaresFitBase(x, y), _order(order), _truncate_order(truncate_order)
{
  if (_truncate_order) // && (_x.size() / 10) < _order)
  {
    if (_x.size() == 1)
      _order = 0;
    else
    {
      _order = (_x.size() / 10) + 1;

      if (_order > order)
        _order = order;
    }
  }
  else if (_x.size() < order)
    throw std::domain_error(
        "Polynomial Fit requires an order less than the size of the input vector");

  _num_coeff = _order + 1;
}

void
PolynomialFit::fillMatrix()
{
  unsigned int num_rows = _x.size();
  unsigned int num_cols = _order + 1;
  _matrix.resize(num_rows * num_cols);

  for (unsigned int col = 0; col < num_cols; ++col)
    for (unsigned int row = 0; row < num_rows; ++row)
    {
      Real value = 1;
      for (unsigned int i = 0; i < col; ++i)
        value *= _x[row];

      _matrix[(col * num_rows) + row] = value;
    }
}

Real
PolynomialFit::sample(Real x)
{
  unsigned int size = _coeffs.size();
  Real value = 0;

  Real curr_x = 1;
  for (unsigned int i = 0; i < size; ++i)
  {
    value += _coeffs[i] * curr_x;
    curr_x *= x;
  }
  return value;
}

void
PolynomialFit::dumpSampleFile(std::string base_name,
                              std::string x_label,
                              std::string y_label,
                              float xmin,
                              float xmax,
                              float ymin,
                              float ymax)
{
  std::stringstream filename, filename_pts;
  const unsigned char fill_character = '0';
  const unsigned int field_width = 4;

  filename.fill(fill_character);
  filename << base_name;
  filename.width(field_width);
  filename << _file_number << ".plt";

  filename_pts.fill(fill_character);
  filename_pts << base_name << "_pts";
  filename_pts.width(field_width);
  filename_pts << _file_number << ".dat";

  /* First dump the GNUPLOT file with the Least Squares Equations */
  std::ofstream out(filename.str().c_str());
  out.precision(15);
  out.fill(fill_character);

  out << "set terminal postscript color enhanced\n"
      << "set output \"" << base_name;
  out.width(field_width);
  out << _file_number << ".eps\"\n"
      << "set xlabel \"" << x_label << "\"\n"
      << "set ylabel \"" << y_label << "\"\n";
  if (xmin != 0 && xmax != 0)
    out << "set xrange [" << xmin << ":" << xmax << "]\n";
  if (ymin != 0 && ymax != 0)
    out << "set yrange [" << ymin << ":" << ymax << "]\n";
  out << "set key left top\n"
      << "f(x)=";

  for (unsigned int i = 0; i < _coeffs.size(); ++i)
  {
    if (i)
      out << "+";

    out << _coeffs[i];
    for (unsigned int j = 0; j < i; ++j)
      out << "*x";
  }
  out << "\nplot f(x) with lines, '" << filename_pts.str() << "' using 1:2 title \"Points\"\n";
  out.close();

  libmesh_assert(_x.size() == _y.size());

  out.open(filename_pts.str().c_str());
  if (out.fail())
    throw std::runtime_error(std::string("Unable to open file ") + filename_pts.str());

  /* Next dump the data points into a seperate file */
  for (unsigned int i = 0; i < _x.size(); ++i)
    out << _x[i] << " " << _y[i] << "\n";
  out << std::endl;

  ++_file_number;
  out.close();
}
